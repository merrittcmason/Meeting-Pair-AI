const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

class ObsidianService {
  constructor() {
    this.config = null;
    this.vaultPath = null;
    this.currentNotePath = null;
  }

  async updateConfig(config) {
    this.config = config;
    this.vaultPath = config.obsidianVaultPath;
    
    if (this.vaultPath) {
      await this.ensureVaultExists();
    }
  }

  async ensureVaultExists() {
    try {
      await fs.access(this.vaultPath);
    } catch (error) {
      // Create vault directory if it doesn't exist
      await fs.mkdir(this.vaultPath, { recursive: true });
    }
  }

  async createMeetingNote() {
    if (!this.vaultPath) {
      throw new Error('Obsidian vault path not configured');
    }

    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-');
    const fileName = `Meeting_${dateStr}_${timeStr}.md`;
    
    this.currentNotePath = path.join(this.vaultPath, fileName);

    const initialContent = `# Meeting Notes - ${now.toLocaleDateString()} ${now.toLocaleTimeString()}

## Attendees
- 

## Agenda
- 

## Discussion

## Action Items
- 

## Next Steps
- 

---
*Generated by Meeting Pair AI*
`;

    await fs.writeFile(this.currentNotePath, initialContent, 'utf8');
    return this.currentNotePath;
  }

  async appendToNote(content) {
    if (!this.currentNotePath) {
      await this.createMeetingNote();
    }

    try {
      const timestamp = new Date().toLocaleTimeString();
      const formattedContent = `\n### ${timestamp}\n${content}\n`;
      
      await fs.appendFile(this.currentNotePath, formattedContent, 'utf8');
      
      // Trigger Obsidian refresh if it's open
      await this.refreshObsidian();
    } catch (error) {
      console.error('Failed to append to note:', error);
    }
  }

  async appendImageNote(imageAnalysis) {
    if (!this.currentNotePath) {
      await this.createMeetingNote();
    }

    try {
      const timestamp = new Date().toLocaleTimeString();
      const imageContent = `\n### Visual Capture - ${timestamp}\n**Description:** ${imageAnalysis.description}\n\n**Extracted Text:**\n${imageAnalysis.extractedText}\n\n---\n`;
      
      await fs.appendFile(this.currentNotePath, imageContent, 'utf8');
      await this.refreshObsidian();
    } catch (error) {
      console.error('Failed to append image note:', error);
    }
  }

  async openVault() {
    if (!this.vaultPath) {
      console.error('Obsidian vault path not configured');
      return;
    }

    try {
      // Try to open with Obsidian
      await execAsync(`open "obsidian://open?vault=${encodeURIComponent(path.basename(this.vaultPath))}"`);
    } catch (error) {
      // Fallback to opening the folder
      try {
        await execAsync(`open "${this.vaultPath}"`);
      } catch (fallbackError) {
        console.error('Failed to open vault:', fallbackError);
      }
    }
  }

  async refreshObsidian() {
    // Send refresh signal to Obsidian if it's running
    try {
      await execAsync('osascript -e \'tell application "Obsidian" to activate\'');
    } catch (error) {
      // Obsidian might not be running, which is fine
    }
  }

  async getCurrentNote() {
    if (!this.currentNotePath) return null;

    try {
      const content = await fs.readFile(this.currentNotePath, 'utf8');
      return {
        path: this.currentNotePath,
        content: content,
        lastModified: (await fs.stat(this.currentNotePath)).mtime
      };
    } catch (error) {
      console.error('Failed to read current note:', error);
      return null;
    }
  }

  async listRecentNotes(limit = 10) {
    if (!this.vaultPath) return [];

    try {
      const files = await fs.readdir(this.vaultPath);
      const mdFiles = files.filter(file => file.endsWith('.md'));
      
      const fileStats = await Promise.all(
        mdFiles.map(async (file) => {
          const filePath = path.join(this.vaultPath, file);
          const stats = await fs.stat(filePath);
          return {
            name: file,
            path: filePath,
            modified: stats.mtime
          };
        })
      );

      return fileStats
        .sort((a, b) => b.modified - a.modified)
        .slice(0, limit);
    } catch (error) {
      console.error('Failed to list notes:', error);
      return [];
    }
  }
}

module.exports = { ObsidianService };